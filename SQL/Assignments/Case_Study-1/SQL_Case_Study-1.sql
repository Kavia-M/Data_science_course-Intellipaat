-- Creating and using A new database for case study 1
CREATE DATABASE Case_Study1;
USE Case_Study1;

-- Checking after loading from csv files
exec sp_help [location];
exec sp_help [Product];
-- using [ ] for the colunm name state ans product as they are reserved keywords
select max(len([State])), max(len(Market)), max(len(Market_Size)) from location;
select max(len(Product_Type)), max(len([Product])), max(len([Type])) from [Product];

exec sp_help fact;
select * from fact;


-- solving Questions
-- 1. Display the number of states present in theLocationTable.

select * from [location];

-- to manualy see how many rows are selected. it returns 20 rows
select count(*), [State] from [Location] group by [State];

-- The answer is the below query to select distinct values from state column
-- since a state can have many areas, it would be repeated in table, distinct should be used
SELECT COUNT(DISTINCT [State])  as number_of_states FROM [Location]; 


-- 2. Howmany products are of regular type?

SELECT count(*) as count_of_products FROM [Product] WHERE [Type] = 'Regular';

-- Using the Primary Key in count
SELECT count(ProductId) as count_of_products FROM [Product] WHERE [Type] = 'Regular';

-- Usign Group By and having
select count(*) as count_of_products, [Type]
from [Product] 
group by [Type] 
HAVING [Type] = 'Regular';

-- Using Group By with Primary Key in count and using Where
select count(ProductId) as count_of_products, [Type]
from [Product] 
WHERE [Type] = 'Regular'
group by [Type];


-- 3. Howmuch spending has been done on marketing of product ID1?
-- Considering the Marketing column in Fact table refers to spending on marketing

select SUM(Marketing) from Fact where ProductId = 1;

-- Using Group By and Having
SELECT ProductId, SUM(Marketing) as spending_on_marketing
FROM Fact
GROUP BY ProductId
HAVING ProductId = 1;

-- Using Group By and where
SELECT ProductId, SUM(Marketing) as spending_on_marketing
FROM Fact
WHERE ProductId = 1
GROUP BY ProductId;


-- 4. What is the minimum sales of a product?
SELECT ProductId, MIN(Sales) as minimum_sales
FROM Fact
GROUP BY ProductId;

-- Additional Implementation to display the product name also
SELECT P.ProductId, P.[Product], MIN(F.Sales) as minimum_sales
FROM Fact F
JOIN [Product] P
ON F.ProductId = P.ProductId
GROUP BY P.ProductId, P.[Product];


-- 5. Display the max Cost of Good Sold (COGS).
-- overall maximum is selected since nothing is specified in the question
SELECT max(COGS) as max_COGS FROM Fact;

-- 6. Display the details of the product where product type iscoffee.
SELECT * FROM [Product] WHERE [Product_Type] = 'Coffee';

-- 7. Display the details where total expenses are greater than40.
SELECT * FROM Fact WHERE Total_Expenses > 40;

-- Additional Implementation to get all details from [Product] and [Location] table as well
SELECT * 
FROM Fact F
JOIN [Product] P
ON F.ProductId = P.ProductId
JOIN [Location] L
ON F.Area_Code = L.Area_Code
WHERE F.Total_Expenses > 40;

-- 8. What is the average sales in area code 719?
SELECT Area_Code, AVG(Sales) as Avg_Sales
FROM Fact
GROUP BY Area_Code
HAVING Area_Code = 719;

-- we can also use where to filter out before grouping 
SELECT Area_Code, AVG(Sales) as Avg_Sales
FROM Fact
WHERE Area_Code = 719
GROUP BY Area_Code;

-- 9. Find out the total profit generated by Colorado state.
SELECT SUM(F.Profit) as Total_Profit FROM
Fact F
JOIN [Location] L
ON F.Area_Code = L.Area_Code
WHERE L.[State] = 'Colorado';

-- using Group By and Where
SELECT L.[State], SUM(F.Profit) as Total_Profit FROM
Fact F
JOIN [Location] L
ON F.Area_Code = L.Area_Code
WHERE L.[State] = 'Colorado'
GROUP BY L.[State];

-- Using Group by and Having
SELECT L.[State], SUM(F.Profit) FROM
Fact F
JOIN [Location] L
ON F.Area_Code = L.Area_Code
GROUP BY L.[State]
HAVING L.[State] = 'Colorado';


-- 10. Display the average inventory for each product ID.
SELECT ProductId, AVG(Inventory) as Avg_Inventory
FROM Fact
GROUP BY ProductId;

-- Additional Implementation - Usign Order By for better reasability of results
SELECT ProductId, AVG(Inventory) as Avg_Inventory
FROM Fact
GROUP BY ProductId
ORDER BY ProductId;


-- 11. Display state in a sequential order in a LocationTable.

-- Ascending order by default for distinct states
SELECT DISTINCT [State] FROM [Location] ORDER BY [State];

-- Descending order for distinct states
SELECT DISTINCT [State] FROM [Location] ORDER BY [State] DESC;

-- Ordering for all states including duplicates
SELECT [State] FROM [Location] ORDER BY [State];
SELECT [State] FROM [Location] ORDER BY [State] DESC;


-- Additional Implementation - Select all rows order by state
SELECT * FROM [Location] ORDER BY [State];
SELECT * FROM [Location] ORDER BY [State] DESC;


-- 12. Display the average budget of the Product where the average budget
-- margin should be greater than 100.

-- Assuming the average budget mentioned here is average Budget Sales
SELECT ProductId, AVG(Budget_Sales) AS Avg_Budget_Sales
FROM Fact
GROUP BY ProductId
HAVING AVG(Budget_Margin) > 100;

-- To display the above details along with Product Name
SELECT P.ProductId, P.[Product], AVG(F.Budget_Sales) AS Avg_Budget_Sales
FROM Fact F
JOIN [Product] P
ON F.ProductId = P.ProductId
GROUP BY P.ProductId, P.[Product]
HAVING AVG(F.Budget_Margin) > 100;

-- Similarly to display other budgets
-- Incase the question mentioned some other budgets the following query would work
SELECT 
	ProductId,
	AVG(Budget_Profit) AS Avg_Budget_Profit,
	AVG(Budget_COGS) AS Avg_Budget_COGS,
	AVG(Budget_Margin) AS Avg_Budget_Margin,
	AVG(Budget_Sales) AS Avg_Budget_Sales
FROM Fact
GROUP BY ProductId
HAVING AVG(Budget_Margin) > 100;

-- To display the above details along with Product Name
SELECT 
	P.ProductId, 
	P.[Product], 
	AVG(F.Budget_Profit) AS Avg_Budget_Profit,
	AVG(F.Budget_COGS) AS Avg_Budget_COGS,
	AVG(F.Budget_Margin) AS Avg_Budget_Margin,
	AVG(F.Budget_Sales) AS Avg_Budget_Sales
FROM Fact F
JOIN [Product] P
ON F.ProductId = P.ProductId
GROUP BY P.ProductId, P.[Product]
HAVING AVG(F.Budget_Margin) > 100;

-- 13. What is the total sales done on date 2010-01-01?
SELECT SUM(Sales) as Total_Sales FROM Fact WHERE [Date] = '01-01-2010';

-- Using Group by
SELECT [Date], SUM(Sales) AS Total_Sales
FROM Fact
WHERE [Date] = '01-01-2010'
GROUP BY [Date];

-- Using Group by and Having
SELECT [Date], SUM(Sales) AS Total_Sales
FROM Fact
GROUP BY [Date]
HAVING [Date] = '01-01-2010';


-- 14. Display the average total expense of each product ID on anindividual date.
SELECT ProductId, [Date], AVG(Total_Expenses) 
FROM Fact
GROUP BY ProductId, [Date]
ORDER BY ProductId, [Date];


-- 15. Display the table with the following attributes such as date, productID,
-- product_type, product, sales, profit, state, area_code.

SELECT 
	F.[Date],
	P.ProductId,
	P.Product_Type,
	P.[Product],
	F.Sales,
	F.Profit,
	L.[State],
	L.Area_Code
FROM Fact F
JOIN [Product] P
ON F.ProductId = P.ProductId
JOIN [Location] L
ON F.Area_Code = L.Area_Code;


-- 16. Display the rank without any gap to show the sales wiserank.

-- Dense Rank is RANK without GAP
SELECT 
	DENSE_RANK() OVER (ORDER BY Sales DESC) AS Sales_wise_rank,
	*
FROM Fact;

-- The folowing 2 queries are wrong answer for the Question
-- Row Number is sqquence and not RANK
-- Rank() gives GAP
SELECT 
	ROW_NUMBER() OVER (ORDER BY Sales DESC) AS Sales_wise_rank,
	*
FROM Fact;

SELECT 
	RANK() OVER (ORDER BY Sales DESC) AS Sales_wise_rank,
	*
FROM Fact;


-- 17. Find the state wise profit and sales.

-- A State has multiple areas 
-- each area code can have multiple rows in Fact table
-- the Sum of Profit and Sales would work
SELECT 
	L.[State],
	SUM(F.Sales) AS Total_Sales,
	SUM(F.Profit) AS Total_Profit
FROM Fact F
JOIN [Location] L
ON F.Area_Code = L.Area_Code
GROUP BY L.[State];


-- 18. Find the state wise profit and sales along with the productname.
-- For each state, for each ProductId (each productID has unique Product name),
-- it calculates total profit and total sales
SELECT 
	L.[State],
	P.ProductId,
	P.[Product],
	SUM(F.Profit) AS Total_Profit,
	SUM(F.Sales) AS Total_Sales
FROM Fact F
JOIN [Product] P
ON F.ProductId = P.ProductId
JOIN [Location] L
ON F.Area_Code = L.Area_Code
GROUP BY L.[State], P.ProductId, P.[Product]
ORDER BY L.[State], P.[Product];

-- alternative implmentation - using only State and product name in group by
-- rollup 
SELECT 
	L.[State],
	P.[Product],
	SUM(F.Profit) AS Total_Profit,
	SUM(F.Sales) AS Total_Sales
FROM Fact F
JOIN [Product] P
ON F.ProductId = P.ProductId
JOIN [Location] L
ON F.Area_Code = L.Area_Code
GROUP BY ROLLUP (L.[State], P.[Product]);

-- 19. If there is an increase in sales of 5%, calculate the increasedsales.

--since sales is number of sales which is whole number and any fraction cannot be considered
-- because even 0.95 sales cannot be 1 sale as a whole number so Floor would work
SELECT Sales, Floor(Sales + Sales*0.05) AS Increased_sales from Fact;

-- Displaying along with Increase in Number of sales
SELECT Sales, FLOOR(Sales*0.05) AS Increase_in_sales, FLOOR(Sales + Sales*0.05) AS Increased_sales FROM Fact;

-- Using CTE to calclate the increase in number of sales before hand
WITH SalesIncreaseCalculation
AS
(
	SELECT Sales, FLOOR(Sales*0.05) AS Increase_in_sales FROM Fact
)
	SELECT *, FLOOR(Sales + Increase_in_sales) AS Increased_sales FROM SalesIncreaseCalculation;

-- Additional Implementation
-- Round is used in the following query, but this is not logic of whole numbers
-- Floor is logically correct for the Sales column
SELECT 
	Sales, 
	ROUND((Sales*0.05), 0) AS Increase_in_sales, 
	ROUND((Sales + Sales*0.05), 0) AS Increased_sales 
FROM Fact;


-- 20.  Find the maximum profit along with the product ID and producttype.
SELECT P.ProductId, P.Product_Type, MAX(F.Profit) AS Max_Profit FROM
Fact F
JOIN [Product] P
ON F.ProductId = P.ProductId
GROUP BY P.ProductId, P.Product_Type
ORDER BY P.ProductId;


-- 21. Create a stored procedure to fetch the result according to theproduct type
-- from ProductTable.
CREATE PROC USP_RESULT_FOR_PRODUCT_TYPE
@ProductType VARCHAR(50)
AS
(
	SELECT * FROM [Product] WHERE Product_Type =  @ProductType
);

EXEC USP_RESULT_FOR_PRODUCT_TYPE @ProductType = 'Coffee';
EXEC USP_RESULT_FOR_PRODUCT_TYPE @ProductType = 'Espresso';
EXEC USP_RESULT_FOR_PRODUCT_TYPE 'Herbal Tea';
-- the following syntax without EXEC can be run isolatedly only
-- cannot be run with selected with other quesries
USP_RESULT_FOR_PRODUCT_TYPE 'Tea';

-- Additional Implementation - Results with Fact
CREATE PROCEDURE USP_RESULT_WITH_FACT_FOR_PRODUCT_TYPE
@ProductType VARCHAR(50)
AS
(
	SELECT * FROM 
	[Product] P
	JOIN FACT F
	ON P.ProductId = F.ProductId
	WHERE P.Product_Type =  @ProductType
);

EXEC USP_RESULT_WITH_FACT_FOR_PRODUCT_TYPE @ProductType = 'Coffee';
EXEC USP_RESULT_WITH_FACT_FOR_PRODUCT_TYPE @ProductType = 'Espresso';
EXEC USP_RESULT_WITH_FACT_FOR_PRODUCT_TYPE 'Herbal Tea';
-- the following syntax without EXEC can be run isolatedly only
-- cannot be run with selected with other quesries
USP_RESULT_WITH_FACT_FOR_PRODUCT_TYPE 'Tea';


-- Additional Implementation - Results with Fact and Location
CREATE PROCEDURE USP_RESULT_WITH_FACT_AND_LOCATION_FOR_PRODUCT_TYPE
@ProductType VARCHAR(50)
AS
BEGIN
	SELECT * FROM 
	[Product] P
	JOIN FACT F
	ON P.ProductId = F.ProductId
	JOIN [Location] L
	ON F.Area_Code = L.Area_Code
	WHERE P.Product_Type =  @ProductType
END;

EXEC USP_RESULT_WITH_FACT_AND_LOCATION_FOR_PRODUCT_TYPE @ProductType = 'Coffee';
EXEC USP_RESULT_WITH_FACT_AND_LOCATION_FOR_PRODUCT_TYPE @ProductType = 'Espresso';
EXEC USP_RESULT_WITH_FACT_AND_LOCATION_FOR_PRODUCT_TYPE 'Herbal Tea';
-- the following syntax without EXEC can be run isolatedly only
-- cannot be run with selected with other quesries
USP_RESULT_WITH_FACT_AND_LOCATION_FOR_PRODUCT_TYPE 'Tea';


-- 22. Write a query by creating a condition in which if the total expenses isless than
-- 60 then it is a profit or else loss.
SELECT 
	Total_Expenses,
	IIF(Total_Expenses < 60, 'Profit', 'Loss') AS PnL_Status
FROM Fact;


-- 23. Give the total weekly sales value with the date and product IDdetails. Use
-- roll-up to pull the data in hierarchical order.

-- Since DATEPART(WEEK, [Date]) gives number 1 to 52,
-- that is number of the week that date lies in that year,
-- We should use that along with the year
SELECT 
	DATEPART(YEAR, [Date]) as Year_of_Date,
	DATEPART(WEEK, [Date]) as Week_of_Date,
	ProductId,
	SUM(Sales) as Total_weekly_sales
FROM Fact
GROUP BY ROLLUP (DATEPART(YEAR, [Date]), DATEPART(WEEK, [Date]), ProductId);


-- 24. Apply union and intersection operator on the tables which consistof
-- attribute area code.

-- Union and Intersection can be applied to 
-- same number of columns with matching datatype and order
-- Area_code is present in Fact and [Location] tables
-- we can only select that column
-- whole table union or intersection is not possible

-- Union gives the area code present either of the tables without duplicates
SELECT Area_Code FROM [Location] 
UNION 
SELECT Area_Code FROM Fact;

-- Intersect gives the area code that is present in both the tables
SELECT Area_Code FROM [Location] 
INTERSECT 
SELECT Area_Code FROM Fact;

-- Additional Implementation
-- Union All gives the area code present either of the tables with duplicates
SELECT Area_Code FROM [Location] 
UNION ALL
SELECT Area_Code FROM Fact;


-- 25. Create a user-defined function for the product table to fetch aparticular
-- product type based upon the user’s preference
CREATE FUNCTION FN_PRODUCT_TYPE_FILTER
(
	@ProductType VARCHAR(50)
)
RETURNS TABLE
AS
RETURN
(
	SELECT * FROM[Product] WHERE Product_Type=@ProductType
);

SELECT * FROM DBO.FN_PRODUCT_TYPE_FILTER('Coffee');
SELECT ProductId FROM DBO.FN_PRODUCT_TYPE_FILTER('Espresso');
SELECT [Product] FROM DBO.FN_PRODUCT_TYPE_FILTER('tea');
SELECT Product_Type FROM DBO.FN_PRODUCT_TYPE_FILTER('HERBAL TEA');

-- The following fucntion call works but not recommended to use
-- since dbo is out default schema and we are working there
-- without dbo function call also works
SELECT * FROM FN_PRODUCT_TYPE_FILTER('Coffee');


-- 26. Change the product type from coffee to tea where product ID is 1and undo
-- it.

-- checking before transaction
SELECT * FROM [Product];
SELECT * FROM [Product] WHERE ProductId = 1;
SELECT Product_Type FROM [Product] WHERE ProductId = 1;

-- Transaction with name
BEGIN TRANSACTION Update_Product_1
UPDATE [Product]
SET Product_Type = 'Tea'
WHERE ProductId = 1;

-- chekcing after transaction
SELECT * FROM [Product];
SELECT * FROM [Product] WHERE ProductId = 1;
SELECT Product_Type FROM [Product] WHERE ProductId = 1;

-- undo the update
ROLLBACK TRANSACTION Update_Product_1;

-- checking after rollback
SELECT * FROM [Product];
SELECT * FROM [Product] WHERE ProductId = 1;
SELECT Product_Type FROM [Product] WHERE ProductId = 1;


-- Alternative Implementation - Transaction without name
BEGIN TRANSACTION
UPDATE [Product]
SET Product_Type = 'Tea'
WHERE ProductId = 1;

-- chekcing after transaction
SELECT * FROM [Product];
SELECT * FROM [Product] WHERE ProductId = 1;
SELECT Product_Type FROM [Product] WHERE ProductId = 1;

-- undo the update
ROLLBACK;

-- checking after rollback
SELECT * FROM [Product];
SELECT * FROM [Product] WHERE ProductId = 1;
SELECT Product_Type FROM [Product] WHERE ProductId = 1;


-- 27. Display the date, product ID and sales where total expensesare
-- between 100 to 200.
SELECT [Date], ProductId, Sales FROM Fact WHERE Total_Expenses BETWEEN 100 AND 200;


-- 28. Delete the records in the Product Table for regulartype.

-- DML commands Auto commit so we can do without using Begin transaction

-- checking
SELECT * FROM [Product] WHERE [Type] = 'Regular';

-- delete
DELETE FROM [Product] WHERE [Type] = 'Regular';

-- checkign after delete
SELECT * FROM [Product];
SELECT * FROM [Product] WHERE [Type] = 'Regular';


-- Additional Implementation - using begin transaction and commit
BEGIN TRANSACTION
DELETE FROM [Product] WHERE [Type] = 'Regular';

COMMIT;


-- 29. Display the ASCII value of the fifth character from the columnProduct

SELECT 
	[Product], 
	ASCII(SUBSTRING([Product], 5, 1)) AS ASCII_VALUE_OF_FIFTH_CHARACTER
FROM [Product];

-- Additional Implementation - For more readability in result
-- select 5th character also
SELECT 
	[Product], 
	SUBSTRING([Product], 5, 1) AS FIFTH_CHARACTER,
	ASCII(SUBSTRING([Product], 5, 1)) AS ASCII_VALUE_OF_FIFTH_CHARACTER
FROM [Product];

